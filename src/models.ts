/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    '/embeddings': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Generate dense vector embeddings for input strings (synchronous or asynchronous).
         * Generates dense vector embeddings for input strings in a single batch.
         *     Supports synchronous (fast=true) and asynchronous (fast=false or omitted) modes.
         *
         *     • Synchronous mode processes up to 200 input strings and returns embeddings immediately (HTTP 200).
         *     • Asynchronous mode accepts up to 2,000 input strings and returns a jobId (HTTP 202) to poll via the /jobs endpoint.
         *
         */
        post: operations['createEmbeddings']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/similarity': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Compute cosine similarity between strings (self or cross).
         * Computes pairwise cosine similarity between input strings.
         *     Supports self-similarity (provide `set`) and cross-similarity (provide `set_a` and `set_b`), with synchronous (`fast=true`) and asynchronous (`fast=false` or omitted) modes.
         *
         *     • In synchronous mode, self-similarity supports up to 100 input strings; cross-similarity requires |set_a|×|set_b| ≤ 10,000. Returns similarities immediately (HTTP 200).
         *     • In asynchronous mode, supports larger inputs (self up to 44,721 items; cross with |set_a|×|set_b| ≤ 2,000,000,000) and returns a jobId (HTTP 202) to poll via the /jobs endpoint.
         *
         */
        post: operations['compareSimilarity']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/themes': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Cluster open-ended text responses into thematic groups.
         * Groups input strings into latent themes using LLM-based clustering.
         *     Supports synchronous (fast=true) and asynchronous (fast=false or omitted) modes.
         *
         *      - In synchronous mode, processes up to 200 input strings and returns themes immediately (HTTP 200).
         *      - In asynchronous mode, accepts up to 500 input strings and returns a jobId (HTTP 202) to poll via the /jobs endpoint.
         *
         *     Each theme includes a `shortLabel`, `label`, `description`, and exactly two representative input strings.
         *     Optionally control theme count with `minThemes`, `maxThemes`, and steer focus via `context`.
         *
         */
        post: operations['generateThemes']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/sentiment': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Classify sentiment of each input string.
         * Classifies the sentiment of each input string as positive, negative, neutral, or mixed, with confidence scores ∈ [0,1].
         *     Supports synchronous (fast=true) and asynchronous (fast=false or omitted) modes.
         *
         *      - In synchronous mode, processes up to 200 input strings and returns results immediately (HTTP 200).
         *      - In asynchronous mode, accepts up to 10,000 input strings and returns a jobId (HTTP 202) to poll via the /jobs endpoint.
         *
         *     Optionally supply `version` for reproducible outputs.
         *
         */
        post: operations['analyzeSentiment']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/extractions': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /**
         * Extract elements matching themes from input strings.
         * Extracts substrings from inputs that match the provided themes.
         *     Supports synchronous (fast=true) and asynchronous (fast=false or omitted) modes.
         *
         *      - Both modes support up to 200 input strings and up to 50 themes.
         *      - Synchronous mode returns extraction results immediately (HTTP 200).
         *      - Asynchronous mode returns a jobId (HTTP 202) to poll via the /jobs endpoint.
         *
         *     Returns a 3-dimensional array where `extractions[i][j]` contains matching elements for input `i` and theme `j`.
         *
         */
        post: operations['extractElements']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/jobs': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /**
         * Retrieve status of an asynchronous job.
         * Retrieves the status of a previously submitted long-running job.
         *     Returns `pending`, `completed`, or `failed`. When `completed`, includes
         *     a `resultUrl` to download results.
         *
         */
        get: operations['getJobStatus']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
}
export type webhooks = Record<string, never>
export interface components {
    schemas: {
        ErrorResponse: {
            message: string
            /** Optional array of error detail messages */
            details?: string[]
        }
        EmbeddingsRequest: {
            /** List of input strings. For synchronous (fast=true) mode, max 200; for asynchronous (fast=false or omitted) mode, max 2000. */
            inputs: string[]
            /** Flag indicating synchronous (true) or asynchronous (false) processing. Default false. */
            fast?: boolean
        }
        EmbeddingDocument: {
            id?: string
            text: string
            vector: number[]
        }
        EmbeddingsResponse: {
            embeddings: components['schemas']['EmbeddingDocument'][]
            requestId: string
        }
        SimilarityRequest: {
            /** Array of strings for self-similarity. For synchronous (fast=true), max 100; for asynchronous (fast=false or omitted), max 44,721. */
            set?: string[]
            /** Array of strings for cross-similarity. For synchronous (fast=true), ensure |set_a|×|set_b| ≤ 10,000; for asynchronous (fast=false or omitted), ensure |set_a|×|set_b| ≤ 2,000,000,000. */
            set_a?: string[]
            /** Array of strings for cross-similarity. For synchronous (fast=true), ensure |set_a|×|set_b| ≤ 10,000; for asynchronous (fast=false or omitted), ensure |set_a|×|set_b| ≤ 2,000,000,000. */
            set_b?: string[]
            version?: string
            /** Flag indicating synchronous (true) or asynchronous (false) processing. Default false. */
            fast?: boolean
            /** For cross-similarity, flatten the matrix into a 1-D array. Ignored for self-similarity. Default false. */
            flatten?: boolean
        } & (unknown | unknown)
        SimilarityResponse: {
            /** @enum {string} */
            scenario: 'self' | 'cross'
            /** @enum {string} */
            mode: 'matrix' | 'flattened'
            n: number
            flattened: number[]
            matrix?: number[][]
            requestId: string
        }
        ThemesRequest: {
            /** List of input strings. For synchronous (fast=true) mode, max 200; for asynchronous (fast=false or omitted) mode, max 500. */
            inputs: string[]
            minThemes?: number
            maxThemes?: number
            context?: string
            version?: string
            prune?: number
            /** Flag indicating synchronous (true) or asynchronous (false) processing. Default false. */
            fast?: boolean
        }
        Theme: {
            shortLabel: string
            label: string
            description: string
            /** Two representative input strings for the theme. */
            representatives: string[]
        }
        ThemesResponse: {
            themes: components['schemas']['Theme'][]
            requestId: string
        }
        SentimentRequest: {
            /** List of input strings. For synchronous (fast=true) mode, max 200; for asynchronous (fast=false or omitted) mode, max 10,000. */
            inputs: string[]
            version?: string
            /** Flag indicating synchronous (true) or asynchronous (false) processing. Default false. */
            fast?: boolean
        }
        SentimentResult: {
            /** @enum {string} */
            sentiment: 'positive' | 'negative' | 'neutral' | 'mixed'
            confidence: number
        }
        SentimentResponse: {
            results: components['schemas']['SentimentResult'][]
            requestId: string
        }
        ExtractionsRequest: {
            inputs: string[]
            themes: string[]
            version?: string
            /** Flag indicating synchronous (true) or asynchronous (false) processing. Default false. */
            fast?: boolean
        }
        ExtractionsResponse: {
            /** 3D array of extracted elements, shape [inputs.length][themes.length][K] */
            extractions: string[][][]
            requestId: string
        }
        JobStatusResponse: {
            jobId?: string
            /** @enum {string} */
            status: 'pending' | 'completed' | 'failed'
            resultUrl?: string
        }
    }
    responses: never
    parameters: never
    requestBodies: never
    headers: never
    pathItems: never
}
export type $defs = Record<string, never>
export interface operations {
    createEmbeddings: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['EmbeddingsRequest']
            }
        }
        responses: {
            /** Embeddings successfully created. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['EmbeddingsResponse']
                }
            }
            /** Bad request - validation error (e.g., >200 strings). */
            400: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ErrorResponse']
                }
            }
        }
    }
    compareSimilarity: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['SimilarityRequest']
            }
        }
        responses: {
            /** Similarity values returned successfully. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['SimilarityResponse']
                }
            }
            /** Bad request - validation error (e.g., invalid input). */
            400: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ErrorResponse']
                }
            }
        }
    }
    generateThemes: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['ThemesRequest']
            }
        }
        responses: {
            /** Thematic clustering completed successfully. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ThemesResponse']
                }
            }
            /** Bad request - validation error (e.g., inputs >200 strings). */
            400: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ErrorResponse']
                }
            }
        }
    }
    analyzeSentiment: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['SentimentRequest']
            }
        }
        responses: {
            /** Sentiment analysis results. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['SentimentResponse']
                }
            }
            /** Bad request - validation error. */
            400: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ErrorResponse']
                }
            }
        }
    }
    extractElements: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['ExtractionsRequest']
            }
        }
        responses: {
            /** Extraction results returned successfully. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ExtractionsResponse']
                }
            }
            /** Bad request - validation error. */
            400: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ErrorResponse']
                }
            }
        }
    }
    getJobStatus: {
        parameters: {
            query: {
                /** Unique identifier for the job. */
                jobId: string
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** Job status returned successfully. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['JobStatusResponse']
                }
            }
            /** Missing or invalid jobId query parameter. */
            400: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ErrorResponse']
                }
            }
            /** Job not found. */
            404: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ErrorResponse']
                }
            }
            /** Internal server error. */
            500: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ErrorResponse']
                }
            }
        }
    }
}

export type EmbeddingsRequest = components['schemas']['EmbeddingsRequest']
export type EmbeddingDocument = components['schemas']['EmbeddingDocument']
export type EmbeddingsResponse = components['schemas']['EmbeddingsResponse']
export type EmbeddingResponse = EmbeddingsResponse
export type SimilarityRequest = components['schemas']['SimilarityRequest']
export type SimilarityResponse = components['schemas']['SimilarityResponse']
export type ThemesRequest = components['schemas']['ThemesRequest']
export type Theme = components['schemas']['Theme']
export type ThemesResponse = components['schemas']['ThemesResponse']
export type SentimentRequest = components['schemas']['SentimentRequest']
export type SentimentResult = components['schemas']['SentimentResult']
export type SentimentResponse = components['schemas']['SentimentResponse']
export type ExtractionsRequest = components['schemas']['ExtractionsRequest']
export type ExtractionsResponse = components['schemas']['ExtractionsResponse']
export type JobStatusResponse = components['schemas']['JobStatusResponse']
